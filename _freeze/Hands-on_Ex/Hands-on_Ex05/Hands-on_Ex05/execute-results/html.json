{
  "hash": "d1f77f99860176c23a5c07f13ff830fd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 5\"\nauthor: \"Eugene Toh\"\nexecute:\n  freeze: true\n---\n\n\n# Spatial Weights and Applications\n\n## Importing libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(spdep, tmap, tidyverse)\n```\n:::\n\n\n## Loading of data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `/home/tropicbliss/GitHub/quarto-project/Hands-on_Ex/Hands-on_Ex05/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n## Data wrangling\n\nNow we will need to join the SFO and the CSV dataframe into one. To do that, we combine two tables into one with `left_join` (any column with the same name is overwritten) and select each row from the resulting dataframe to make a new one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, hunan2012)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(County)`\n```\n\n\n:::\n:::\n\n\n## Visualisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.5)\n\ngdppc <- qtm(hunan, \"GDPPC\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_files/figure-html/unnamed-chunk-5-1.png){width=1152}\n:::\n:::\n\n\nRemember, spatial lag is rarely used to estimate data. It is typically used to derive a clear pattern from existing data.\n\n## Computing contiguity weight matrices\n\nIn R, the function `poly2nb()` is part of the **spdep** package, which is used for spatial data analysis. The `poly2nb()` function takes in an SFO and creates a neighbor list for a set of spatial polygons. `poly2nb()` determines which polygons are \"neighbors\" based on whether they touch each other (contiguity). The output is a neighbor object (class `nb`) where each polygon is assigned a list of the IDs of its neighboring polygons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n\n\n:::\n:::\n\n\nThe term **\"queen\"** in spatial analysis refers to a method of defining neighborhood relationships between polygons based on how they touch each other. The name comes from the movement of the queen piece in chess, which can move in any direction—horizontally, vertically, or diagonally.\n\n**Queen contiguity** considers two polygons to be neighbors if they touch at any point, whether they share a full edge (side) or just a corner. This is a broader and more inclusive definition of neighbors compared to **rook contiguity**.\n\nIn rook contiguity, neighbour polygons must share a full edge.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n```\n\n\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one heighbours.\n\nFor each polygon in our polygon object, *wm_q* lists all neighboring polygons. For example, to see the neighbors for the first polygon in the object, type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  3  4 57 85\n```\n\n\n:::\n:::\n\n\nWe can retrive the county name of Polygon ID=1 by using the code chunk below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$County[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Anxiang\"\n```\n\n\n:::\n:::\n\n\nTo reveal the county names of the five neighboring polygons, the code chunk will be used:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan$NAME_3[c(2,3,4,57,85)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n```\n\n\n:::\n:::\n\n\nWe can retrieve the GDPPC (GDP per capita) of these five countries by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20981 34592 24473 21311 22879\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"snap\")= num 9e-08\n - attr(*, \"sym\")= logi TRUE\n - attr(*, \"ncomp\")=List of 2\n  ..$ nc     : num 1\n  ..$ comp.id: num [1:88] 1 1 1 1 1 1 1 1 1 1 ...\n```\n\n\n:::\n:::\n\n\n### Visualising contiguity weights\n\nA connectivity graph takes a point and displays a line to each neighboring point. We are working with polygons at the moment, so we will need to get points in order to make our connectivity graphs. The most typically method for this will be polygon centroids. We will calculate these in the sf package before moving onto the graphs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\nlength(longitude)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 88\n```\n\n\n:::\n\n```{.r .cell-code}\nlongitude[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 112.1531\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- cbind(longitude, latitude)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\", main=\"Queen Contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\nplot(hunan$geometry, border=\"lightgrey\", main=\"Rook Contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n## Computing distance based neighbours\n\nIn this section, you will learn how to derive distance-based weight matrices by using [*dnearneigh()*](https://r-spatial.github.io/spdep/reference/dnearneigh.html) of **spdep** package. The function identifies neighbours of region points by Euclidean distance with a distance band with lower d1= and upper d2= bounds controlled by the bounds= argument. If unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in **km** will be calculated assuming the WGS84 reference ellipsoid.\n\n### Determining the cut-off distance\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in knn2nb(knearneigh(coords)): neighbour object has 25 sub-graphs\n```\n\n\n:::\n\n```{.r .cell-code}\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n```\n\n\n:::\n:::\n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour.\n\n### Computing fixed distance weight matrix\n\nNow, we will compute the distance weight matrix by using *dnearneigh()* as shown in the code chunk below. 0 is the lower bound and 62 is the upper bound of the distance range.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n```\n\n\n:::\n:::\n\n\nNext, we will use *str()* to display the content of wm_d62 weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_d62)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n - attr(*, \"ncomp\")=List of 2\n  ..$ nc     : num 1\n  ..$ comp.id: num [1:88] 1 1 1 1 1 1 1 1 1 1 ...\n```\n\n\n:::\n:::\n\n\nThis returns a list of the indices of nearest neighbours for each point based on a given distance. Don't worry about the numbers surrounded by square brackets, they just tell you the indexes start from 1 onwards.\n\nThis has the problem of a centroid being less effective when the polygon is larger.\n\n### Plotting fixed distance weight matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\", main=\"1st nearest neighbours\")\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\nplot(hunan$geometry, border=\"lightgrey\", main=\"Distance link\")\nplot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n### Computing adaptive distance weight matrix\n\nThis ensures that each point has a total neighbour count of a certain number. In spatial datasets, points or regions can be distributed unevenly. For instance, urban areas may have many more observations (e.g., people, buildings, events) than rural areas (we're not just talking about centroids of polygons here). A fixed distance threshold may result in some points having too many neighbors in densely populated areas and too few neighbors in sparsely populated areas. An adaptive distance weight matrix ensures that each point has a consistent number of neighbors, irrespective of the spatial density.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn6 <- knn2nb(knearneigh(coords, k=6))\nknn6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(knn6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"ncomp\")=List of 2\n  ..$ nc     : num 1\n  ..$ comp.id: num [1:88] 1 1 1 1 1 1 1 1 1 1 ...\n```\n\n\n:::\n:::\n\n\n## Weights based on Inverse Distance Weighting (IDW)\n\nIt estimates the value at an unknown location based on the values at nearby known locations, with the assumption that points that are closer to the unknown location have more influence than points that are farther away.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- nbdists(wm_q, coords, longlat = TRUE)\nids <- lapply(dist, function(x) 1/(x))\nids\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n\n[[4]]\n[1] 0.01820896 0.02822040 0.03414741 0.01539065\n\n[[5]]\n[1] 0.03695795 0.03414741 0.01524598 0.01618354\n\n[[6]]\n[1] 0.015390649 0.015245977 0.021748129 0.011883901 0.009810297\n\n[[7]]\n[1] 0.01708612 0.01473997 0.01150924 0.01872915\n\n[[8]]\n[1] 0.02022144 0.03453056 0.02529256 0.01036340 0.02284457 0.01500600 0.01515314\n\n[[9]]\n[1] 0.02022144 0.01574888 0.02109502 0.01508028 0.02902705 0.01502980\n\n[[10]]\n[1] 0.02281552 0.01387777 0.01538326 0.01346650 0.02100510 0.02631658 0.01874863\n[8] 0.01500046\n\n[[11]]\n[1] 0.01882869 0.02243492 0.02247473\n\n[[12]]\n[1] 0.02779227 0.02419652 0.02333385 0.02986130 0.02335429\n\n[[13]]\n[1] 0.02779227 0.02650020 0.02670323 0.01714243\n\n[[14]]\n[1] 0.01882869 0.01233868 0.02098555\n\n[[15]]\n[1] 0.02650020 0.01233868 0.01096284 0.01562226\n\n[[16]]\n[1] 0.02281552 0.02466962 0.02765018 0.01476814 0.01671430\n\n[[17]]\n[1] 0.01387777 0.02243492 0.02098555 0.01096284 0.02466962 0.01593341 0.01437996\n\n[[18]]\n[1] 0.02039779 0.02032767 0.01481665 0.01473691 0.01459380\n\n[[19]]\n[1] 0.01538326 0.01926323 0.02668415 0.02140253 0.01613589 0.01412874\n\n[[20]]\n[1] 0.01346650 0.02039779 0.01926323 0.01723025 0.02153130 0.01469240 0.02327034\n\n[[21]]\n[1] 0.02668415 0.01723025 0.01766299 0.02644986 0.02163800\n\n[[22]]\n[1] 0.02100510 0.02765018 0.02032767 0.02153130 0.01489296\n\n[[23]]\n[1] 0.01481665 0.01469240 0.01401432 0.02246233 0.01880425 0.01530458 0.01849605\n\n[[24]]\n[1] 0.02354598 0.01837201 0.02607264 0.01220154 0.02514180\n\n[[25]]\n[1] 0.02354598 0.02188032 0.01577283 0.01949232 0.02947957\n\n[[26]]\n[1] 0.02155798 0.01745522 0.02212108 0.02220532\n\n[[27]]\n[1] 0.02155798 0.02490625 0.01562326\n\n[[28]]\n[1] 0.01837201 0.02188032 0.02229549 0.03076171 0.02039506\n\n[[29]]\n[1] 0.02490625 0.01686587 0.01395022\n\n[[30]]\n[1] 0.02090587\n\n[[31]]\n[1] 0.02607264 0.01577283 0.01219005 0.01724850 0.01229012 0.01609781 0.01139438\n[8] 0.01150130\n\n[[32]]\n[1] 0.01220154 0.01219005 0.01712515 0.01340413 0.01280928 0.01198216 0.01053374\n[8] 0.01065655\n\n[[33]]\n[1] 0.01949232 0.01745522 0.02229549 0.02090587 0.01979045\n\n[[34]]\n[1] 0.03113041 0.03589551 0.02882915\n\n[[35]]\n[1] 0.01766299 0.02185795 0.02616766 0.02111721 0.02108253 0.01509020\n\n[[36]]\n[1] 0.01724850 0.03113041 0.01571707 0.01860991 0.02073549 0.01680129\n\n[[37]]\n[1] 0.01686587 0.02234793 0.01510990 0.01550676\n\n[[38]]\n[1] 0.01401432 0.02407426 0.02276151 0.01719415\n\n[[39]]\n[1] 0.01229012 0.02172543 0.01711924 0.02629732 0.01896385\n\n[[40]]\n[1] 0.01609781 0.01571707 0.02172543 0.01506473 0.01987922 0.01894207\n\n[[41]]\n[1] 0.02246233 0.02185795 0.02205991 0.01912542 0.01601083 0.01742892\n\n[[42]]\n[1] 0.02212108 0.01562326 0.01395022 0.02234793 0.01711924 0.01836831 0.01683518\n\n[[43]]\n[1] 0.01510990 0.02629732 0.01506473 0.01836831 0.03112027 0.01530782\n\n[[44]]\n[1] 0.01550676 0.02407426 0.03112027 0.01486508\n\n[[45]]\n[1] 0.03589551 0.01860991 0.01987922 0.02205991 0.02107101 0.01982700\n\n[[46]]\n[1] 0.03453056 0.04033752 0.02689769\n\n[[47]]\n[1] 0.02529256 0.02616766 0.04033752 0.01949145 0.02181458\n\n[[48]]\n[1] 0.02313819 0.03370576 0.02289485 0.01630057 0.01818085\n\n[[49]]\n[1] 0.03076171 0.02138091 0.02394529 0.01990000\n\n[[50]]\n[1] 0.01712515 0.02313819 0.02551427 0.02051530 0.02187179\n\n[[51]]\n[1] 0.03370576 0.02138091 0.02873854\n\n[[52]]\n[1] 0.02289485 0.02394529 0.02551427 0.02873854 0.03516672\n\n[[53]]\n[1] 0.01630057 0.01979945 0.01253977\n\n[[54]]\n[1] 0.02514180 0.02039506 0.01340413 0.01990000 0.02051530 0.03516672\n\n[[55]]\n[1] 0.01280928 0.01818085 0.02187179 0.01979945 0.01882298\n\n[[56]]\n[1] 0.01036340 0.01139438 0.01198216 0.02073549 0.01214479 0.01362855 0.01341697\n\n[[57]]\n[1] 0.028079221 0.017643082 0.031423501 0.029114131 0.013520292 0.009903702\n\n[[58]]\n[1] 0.01925924 0.03142350 0.02722997 0.01434859 0.01567192\n\n[[59]]\n[1] 0.01696711 0.01265572 0.01667105 0.01785036\n\n[[60]]\n[1] 0.02419652 0.02670323 0.01696711 0.02343040\n\n[[61]]\n[1] 0.02333385 0.01265572 0.02343040 0.02514093 0.02790764 0.01219751 0.02362452\n\n[[62]]\n[1] 0.02514093 0.02002219 0.02110260\n\n[[63]]\n[1] 0.02986130 0.02790764 0.01407043 0.01805987\n\n[[64]]\n[1] 0.02911413 0.01689892\n\n[[65]]\n[1] 0.02471705\n\n[[66]]\n[1] 0.01574888 0.01726461 0.03068853 0.01954805 0.01810569\n\n[[67]]\n[1] 0.01708612 0.01726461 0.01349843 0.01361172\n\n[[68]]\n[1] 0.02109502 0.02722997 0.03068853 0.01406357 0.01546511\n\n[[69]]\n[1] 0.02174813 0.01645838 0.01419926\n\n[[70]]\n[1] 0.02631658 0.01963168 0.02278487\n\n[[71]]\n[1] 0.01473997 0.01838483 0.03197403\n\n[[72]]\n[1] 0.01874863 0.02247473 0.01476814 0.01593341 0.01963168\n\n[[73]]\n[1] 0.01500046 0.02140253 0.02278487 0.01838483 0.01652709\n\n[[74]]\n[1] 0.01150924 0.01613589 0.03197403 0.01652709 0.01342099 0.02864567\n\n[[75]]\n[1] 0.011883901 0.010533736 0.012539774 0.018822977 0.016458383 0.008217581\n\n[[76]]\n[1] 0.01352029 0.01434859 0.01689892 0.02471705 0.01954805 0.01349843 0.01406357\n\n[[77]]\n[1] 0.014736909 0.018804247 0.022761507 0.012197506 0.020022195 0.014070428\n[7] 0.008440896\n\n[[78]]\n[1] 0.02323898 0.02284457 0.01508028 0.01214479 0.01567192 0.01546511 0.01140779\n\n[[79]]\n[1] 0.01530458 0.01719415 0.01894207 0.01912542 0.01530782 0.01486508 0.02107101\n\n[[80]]\n[1] 0.01500600 0.02882915 0.02111721 0.01680129 0.01601083 0.01982700 0.01949145\n[8] 0.01362855\n\n[[81]]\n[1] 0.02947957 0.02220532 0.01150130 0.01979045 0.01896385 0.01683518\n\n[[82]]\n[1] 0.02327034 0.02644986 0.01849605 0.02108253 0.01742892\n\n[[83]]\n[1] 0.023354289 0.017142433 0.015622258 0.016714303 0.014379961 0.014593799\n[7] 0.014892965 0.018059871 0.008440896\n\n[[84]]\n[1] 0.01872915 0.02902705 0.01810569 0.01361172 0.01342099 0.01297994\n\n[[85]]\n [1] 0.011451133 0.017193502 0.013957649 0.016183544 0.009810297 0.010656545\n [7] 0.013416965 0.009903702 0.014199260 0.008217581 0.011407794\n\n[[86]]\n[1] 0.01515314 0.01502980 0.01412874 0.02163800 0.01509020 0.02689769 0.02181458\n[8] 0.02864567 0.01297994\n\n[[87]]\n[1] 0.01667105 0.02362452 0.02110260 0.02058034\n\n[[88]]\n[1] 0.01785036 0.02058034\n```\n\n\n:::\n:::\n\n\n**`function(x) 1/(x)`**: This function takes each vector of distances (`x`) from the list `dist` and computes the **inverse** of those distances (i.e., `1 / distance`).\n\n-   The result of applying this function is that points closer to each other will have a larger value (since the inverse of a small distance is large), and points farther away will have smaller values.\n\n**`lapply()`**: This function applies a given function to each element of a list (`dist` in this case). It loops over each element of the list and applies the specified function.\n\nThe result (`ids`) will be a list where each element contains the inverse distances between a point and its neighbors.\n\nKnowing the inverse distances alone isn't inherently useful unless you are applying them for a specific purpose in spatial analysis. The **inverse distance** is typically used as a weight in various spatial models or techniques, where **closer points** have **more influence** than distant ones. One drawback is that this method does not do edge correction, which means that points around the edges will have less neighbours and hence lower values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n\n\n:::\n:::\n\n\nTo see the weight of the first polygon’s eight neighbors type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q$weights[10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n```\n\n\n:::\n:::\n\n\nEach neighbor is assigned a 0.125 of the total weight. This means that when R computes the average neighboring income values, each neighbor’s income will be multiplied by 0.125 before being tallied.\n\n```         \nlibrary(spdep)\n\n# Example: coords is your matrix of known point coordinates\n# values contains the known values (e.g., temperature, pollution, etc.)\n# x_0 is the location where you want to estimate the value\nx_0 <- c(lon, lat)  # coordinates of the unknown point\n\n# Calculate the distances between the unknown point and known points\ndistances <- spDistsN1(coords, x_0, longlat = TRUE)\n\n# Set the power parameter for inverse distance (usually 2)\np <- 2\n\n# Calculate inverse distances (weights)\nweights <- 1 / (distances^p)\n\n# Estimate the value at x_0 by calculating the weighted average\nestimated_value <- sum(weights * values) / sum(weights)\n\n# Print the estimated value\nprint(estimated_value)\n```\n\n**\"W\"** stands for **row-standardized weights**. This means that the weights for each row (i.e., for each observation or spatial point) are normalized so that they sum up to 1. In a row-standardized weight matrix, each element is divided by the sum of the weights for that row, ensuring that all the weights for a given point’s neighbors add up to 1.\n\nRow-standardization is useful when you want to make the sum of weights comparable across observations. It helps in cases where some points have many neighbors and others have few, so you ensure that every point contributes equally overall.\n\n**\"B\"** stands for **binary weights**. In this case, each neighbor is either given a weight of **1** (if it is a neighbor) or **0** (if it is not a neighbor). Binary weights are the simplest form of spatial weighting. Each point either has full influence on its neighbors (weight = 1), or no influence (weight = 0), without considering the distance or the number of neighbors. Binary weights are useful in cases where you are only interested in whether two points are neighbors, without differentiating between them based on distance or proximity. It is a straightforward approach for identifying and analyzing neighborhood structures. All neighbors have the same influence, regardless of how many neighbors exist or how far apart they are.\n\n**`zero.policy = TRUE`**: This allows handling cases where some points have **no neighbors**. If `zero.policy = TRUE`, the function will handle these cases by assigning zero weights to points with no neighbors, instead of causing an error.\n\nThis alone will not give you an estimate of a value given a location. For that, you'll need spatial lagged models.\n\n## Application of Spatial Weight Matrix\n\nIn this section, you will learn how to create four different spatial lagged variables. A spatial lagged model is where the value at a given point is influenced by a weighted average of the values of its neighbors.\n\n### Spatial lag with row-standardised weights\n\nComputing the average neighbor GDPPC value for each polygon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n```\n\n\n:::\n:::\n\n\nEach number correspond to each row in `hunan`.\n\nWe can append the spatially lag GDPPC values onto hunan sf data frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\nlag.res <- as.data.frame(lag.list)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag GDPPC\")\nhunan <- left_join(hunan,lag.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(NAME_3)`\n```\n\n\n:::\n:::\n\n\nThe following table shows the average neighboring income values (stored in the Inc.lag object) for each county.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 36 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County    City\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang Changde\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou Changde\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi Changde\n4 Changde 21102      Li      County   3.474325 0.18908121      Li Changde\n5 Changde 21103   Linli      County   2.289506 0.11450357   Linli Changde\n6 Changde 21104  Shimen      County   4.171918 0.37194707  Shimen Changde\n  avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC     GIO   Loan  NIPCR\n1    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667  5108.9 2806.9 7693.7\n2    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981 13491.0 4550.0 8269.9\n3    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592 10935.0 2242.0 8169.9\n4    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473 18402.0 6748.0 8377.0\n5    32667    564.1  7781.2  336.86  1538.7 10355.0 25554  8214.0  358.0 8143.1\n6    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137 17795.0 6026.5 6156.0\n   Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household Household_R NOIP Pop_R\n1 1931 336.39 270.5 205.9  19.584  17.819     148.1       135.4   53 346.0\n2 2560 456.78 388.8 246.7  42.097  33.029     240.2       208.7   95 553.2\n3  848 122.78  82.1  61.7   8.723   7.592      81.9        43.7   77  92.4\n4 2038 513.44 426.8 227.1  38.975  33.938     268.5       256.0   96 539.7\n5 1440 307.36 272.2 100.8  23.286  18.943     129.1       157.2   99 246.6\n6 2502 392.05 329.6 193.8  29.245  26.104     190.6       184.7  122 399.2\n    RSCG Pop_T    Agri Service Disp_Inc      RORP    ROREmp lag GDPPC\n1 3957.9 528.3 4524.41   14100    16610 0.6549309 0.8041262  24847.20\n2 4460.5 804.6 6545.35   17727    18925 0.6875466 0.8511756  22724.80\n3 3683.0 251.8 2562.46    7525    19498 0.3669579 0.6686757  24143.25\n4 7110.2 832.5 7562.34   53160    18985 0.6482883 0.8312558  27737.50\n5 3604.9 409.3 3583.91    7031    18604 0.6024921 0.8856065  27270.25\n6 6490.7 600.5 5266.51    6981    19275 0.6647794 0.8407091  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n```\n\n\n:::\n:::\n\n\nNext, we will plot both the GDPPC and spatial lag GDPPC for comparison using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, \"GDPPC\")\nlag_gdppc <- qtm(hunan, \"lag GDPPC\")\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n### Spatial lag as a sum of neighbouring values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights <- lapply(wm_q, function(x) 0*x + 1)\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nlag.res <- as.data.frame(lag_sum)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag_sum GDPPC\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, lag.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(NAME_3)`\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngdppc <- qtm(hunan, \"GDPPC\")\nlag_sum_gdppc <- qtm(hunan, \"lag_sum GDPPC\")\ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n### Spatial window average\n\nThe spatial window average uses row-standardized weights and includes the diagonal element. To do this in R, we need to go back to the neighbors structure and add the diagonal element before assigning weights.\n\nTo add the diagonal element to the neighbour list, we just need to use *include.self()* from **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_qs <- include.self(wm_q)\nwm_qs[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  2  3  4 57 85\n```\n\n\n:::\n:::\n\n\nNow we obtain weights with *nb2listw():*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_qs <- nb2listw(wm_qs)\nwm_qs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 30.90265 357.5308\n```\n\n\n:::\n:::\n\n\nLastly, we just need to create the lag variable from our weight structure and GDPPC variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag_w_avg_gpdpc <- lag.listw(wm_qs, \n                             hunan$GDPPC)\nlag_w_avg_gpdpc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 24650.50 22434.17 26233.00 27084.60 26927.00 22230.17 47621.20 37160.12\n [9] 49224.71 29886.89 26627.50 22690.17 25366.40 25825.75 30329.00 32682.83\n[17] 25948.62 23987.67 25463.14 21904.38 23127.50 25949.83 20018.75 19524.17\n[25] 18955.00 17800.40 15883.00 18831.33 14832.50 17965.00 17159.89 16199.44\n[33] 18764.50 26878.75 23188.86 20788.14 12365.20 15985.00 13764.83 11907.43\n[41] 17128.14 14593.62 11644.29 12706.00 21712.29 43548.25 35049.00 16226.83\n[49] 19294.40 18156.00 19954.75 18145.17 12132.75 18419.29 14050.83 23619.75\n[57] 24552.71 24733.67 16762.60 20932.60 19467.75 18334.00 22541.00 26028.00\n[65] 29128.50 46569.00 47576.60 36545.50 20838.50 22531.00 42115.50 27619.00\n[73] 27611.33 44523.29 18127.43 28746.38 20734.50 33880.62 14716.38 28516.22\n[81] 18086.14 21244.50 29568.80 48119.71 22310.75 43151.60 17133.40 17009.33\n```\n\n\n:::\n:::\n\n\nNext, we will convert the lag variable listw object into a data.frame by using *as.data.frame()*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))\nlag_wm_qs.res <- as.data.frame(lag.list.wm_qs)\ncolnames(lag_wm_qs.res) <- c(\"NAME_3\", \"lag_window_avg GDPPC\")\n```\n:::\n\n\nNext, the code chunk below will be used to append *lag_window_avg GDPPC* values onto *hunan* sf data.frame by using *left_join()* of **dplyr** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, lag_wm_qs.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(NAME_3)`\n```\n\n\n:::\n:::\n\n\nTo compare the values of lag GDPPC and Spatial window average, `kable()` of Knitr package is used to prepare a table using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(knitr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan %>%\n  select(\"County\", \n         \"lag GDPPC\", \n         \"lag_window_avg GDPPC\") %>%\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n|County        | lag GDPPC| lag_window_avg GDPPC|geometry                       |\n|:-------------|---------:|--------------------:|:------------------------------|\n|Anxiang       |  24847.20|             24650.50|POLYGON ((112.0625 29.75523... |\n|Hanshou       |  22724.80|             22434.17|POLYGON ((112.2288 29.11684... |\n|Jinshi        |  24143.25|             26233.00|POLYGON ((111.8927 29.6013,... |\n|Li            |  27737.50|             27084.60|POLYGON ((111.3731 29.94649... |\n|Linli         |  27270.25|             26927.00|POLYGON ((111.6324 29.76288... |\n|Shimen        |  21248.80|             22230.17|POLYGON ((110.8825 30.11675... |\n|Liuyang       |  43747.00|             47621.20|POLYGON ((113.9905 28.5682,... |\n|Ningxiang     |  33582.71|             37160.12|POLYGON ((112.7181 28.38299... |\n|Wangcheng     |  45651.17|             49224.71|POLYGON ((112.7914 28.52688... |\n|Anren         |  32027.62|             29886.89|POLYGON ((113.1757 26.82734... |\n|Guidong       |  32671.00|             26627.50|POLYGON ((114.1799 26.20117... |\n|Jiahe         |  20810.00|             22690.17|POLYGON ((112.4425 25.74358... |\n|Linwu         |  25711.50|             25366.40|POLYGON ((112.5914 25.55143... |\n|Rucheng       |  30672.33|             25825.75|POLYGON ((113.6759 25.87578... |\n|Yizhang       |  33457.75|             30329.00|POLYGON ((113.2621 25.68394... |\n|Yongxing      |  31689.20|             32682.83|POLYGON ((113.3169 26.41843... |\n|Zixing        |  20269.00|             25948.62|POLYGON ((113.7311 26.16259... |\n|Changning     |  23901.60|             23987.67|POLYGON ((112.6144 26.60198... |\n|Hengdong      |  25126.17|             25463.14|POLYGON ((113.1056 27.21007... |\n|Hengnan       |  21903.43|             21904.38|POLYGON ((112.7599 26.98149... |\n|Hengshan      |  22718.60|             23127.50|POLYGON ((112.607 27.4689, ... |\n|Leiyang       |  25918.80|             25949.83|POLYGON ((112.9996 26.69276... |\n|Qidong        |  20307.00|             20018.75|POLYGON ((111.7818 27.0383,... |\n|Chenxi        |  20023.80|             19524.17|POLYGON ((110.2624 28.21778... |\n|Zhongfang     |  16576.80|             18955.00|POLYGON ((109.9431 27.72858... |\n|Huitong       |  18667.00|             17800.40|POLYGON ((109.9419 27.10512... |\n|Jingzhou      |  14394.67|             15883.00|POLYGON ((109.8186 26.75842... |\n|Mayang        |  19848.80|             18831.33|POLYGON ((109.795 27.98008,... |\n|Tongdao       |  15516.33|             14832.50|POLYGON ((109.9294 26.46561... |\n|Xinhuang      |  20518.00|             17965.00|POLYGON ((109.227 27.43733,... |\n|Xupu          |  17572.00|             17159.89|POLYGON ((110.7189 28.30485... |\n|Yuanling      |  15200.12|             16199.44|POLYGON ((110.9652 28.99895... |\n|Zhijiang      |  18413.80|             18764.50|POLYGON ((109.8818 27.60661... |\n|Lengshuijiang |  14419.33|             26878.75|POLYGON ((111.5307 27.81472... |\n|Shuangfeng    |  24094.50|             23188.86|POLYGON ((112.263 27.70421,... |\n|Xinhua        |  22019.83|             20788.14|POLYGON ((111.3345 28.19642... |\n|Chengbu       |  12923.50|             12365.20|POLYGON ((110.4455 26.69317... |\n|Dongan        |  14756.00|             15985.00|POLYGON ((111.4531 26.86812... |\n|Dongkou       |  13869.80|             13764.83|POLYGON ((110.6622 27.37305... |\n|Longhui       |  12296.67|             11907.43|POLYGON ((110.985 27.65983,... |\n|Shaodong      |  15775.17|             17128.14|POLYGON ((111.9054 27.40254... |\n|Suining       |  14382.86|             14593.62|POLYGON ((110.389 27.10006,... |\n|Wugang        |  11566.33|             11644.29|POLYGON ((110.9878 27.03345... |\n|Xinning       |  13199.50|             12706.00|POLYGON ((111.0736 26.84627... |\n|Xinshao       |  23412.00|             21712.29|POLYGON ((111.6013 27.58275... |\n|Shaoshan      |  39541.00|             43548.25|POLYGON ((112.5391 27.97742... |\n|Xiangxiang    |  36186.60|             35049.00|POLYGON ((112.4549 28.05783... |\n|Baojing       |  16559.60|             16226.83|POLYGON ((109.7015 28.82844... |\n|Fenghuang     |  20772.50|             19294.40|POLYGON ((109.5239 28.19206... |\n|Guzhang       |  19471.20|             18156.00|POLYGON ((109.8968 28.74034... |\n|Huayuan       |  19827.33|             19954.75|POLYGON ((109.5647 28.61712... |\n|Jishou        |  15466.80|             18145.17|POLYGON ((109.8375 28.4696,... |\n|Longshan      |  12925.67|             12132.75|POLYGON ((109.6337 29.62521... |\n|Luxi          |  18577.17|             18419.29|POLYGON ((110.1067 28.41835... |\n|Yongshun      |  14943.00|             14050.83|POLYGON ((110.0003 29.29499... |\n|Anhua         |  24913.00|             23619.75|POLYGON ((111.6034 28.63716... |\n|Nan           |  25093.00|             24552.71|POLYGON ((112.3232 29.46074... |\n|Yuanjiang     |  24428.80|             24733.67|POLYGON ((112.4391 29.1791,... |\n|Jianghua      |  17003.00|             16762.60|POLYGON ((111.6461 25.29661... |\n|Lanshan       |  21143.75|             20932.60|POLYGON ((112.2286 25.61123... |\n|Ningyuan      |  20435.00|             19467.75|POLYGON ((112.0715 26.09892... |\n|Shuangpai     |  17131.33|             18334.00|POLYGON ((111.8864 26.11957... |\n|Xintian       |  24569.75|             22541.00|POLYGON ((112.2578 26.0796,... |\n|Huarong       |  23835.50|             26028.00|POLYGON ((112.9242 29.69134... |\n|Linxiang      |  26360.00|             29128.50|POLYGON ((113.5502 29.67418... |\n|Miluo         |  47383.40|             46569.00|POLYGON ((112.9902 29.02139... |\n|Pingjiang     |  55157.75|             47576.60|POLYGON ((113.8436 29.06152... |\n|Xiangyin      |  37058.00|             36545.50|POLYGON ((112.9173 28.98264... |\n|Cili          |  21546.67|             20838.50|POLYGON ((110.8822 29.69017... |\n|Chaling       |  23348.67|             22531.00|POLYGON ((113.7666 27.10573... |\n|Liling        |  42323.67|             42115.50|POLYGON ((113.5673 27.94346... |\n|Yanling       |  28938.60|             27619.00|POLYGON ((113.9292 26.6154,... |\n|You           |  25880.80|             27611.33|POLYGON ((113.5879 27.41324... |\n|Zhuzhou       |  47345.67|             44523.29|POLYGON ((113.2493 28.02411... |\n|Sangzhi       |  18711.33|             18127.43|POLYGON ((110.556 29.40543,... |\n|Yueyang       |  29087.29|             28746.38|POLYGON ((113.343 29.61064,... |\n|Qiyang        |  20748.29|             20734.50|POLYGON ((111.5563 26.81318... |\n|Taojiang      |  35933.71|             33880.62|POLYGON ((112.0508 28.67265... |\n|Shaoyang      |  15439.71|             14716.38|POLYGON ((111.5013 27.30207... |\n|Lianyuan      |  29787.50|             28516.22|POLYGON ((111.6789 28.02946... |\n|Hongjiang     |  18145.00|             18086.14|POLYGON ((110.1441 27.47513... |\n|Hengyang      |  21617.00|             21244.50|POLYGON ((112.7144 26.98613... |\n|Guiyang       |  29203.89|             29568.80|POLYGON ((113.0811 26.04963... |\n|Changsha      |  41363.67|             48119.71|POLYGON ((112.9421 28.03722... |\n|Taoyuan       |  22259.09|             22310.75|POLYGON ((112.0612 29.32855... |\n|Xiangtan      |  44939.56|             43151.60|POLYGON ((113.0426 27.8942,... |\n|Dao           |  16902.00|             17133.40|POLYGON ((111.498 25.81679,... |\n|Jiangyong     |  16930.00|             17009.33|POLYGON ((111.3659 25.39472... |\n\n\n:::\n:::\n\n\nLastly, *qtm()* of **tmap** package is used to plot the lag_gdppc and w_ave_gdppc maps next to each other for quick comparison.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_avg_gdppc <- qtm(hunan, \"lag_window_avg GDPPC\")\ntmap_arrange(lag_gdppc, w_avg_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\n### Spatial window sum\n\nThe spatial window sum is the counterpart of the window average, but without using row-standardized weights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_qs <- include.self(wm_q)\nwm_qs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n```\n\n\n:::\n:::\n\n\nNext, we will assign binary weights to the neighbour structure that includes the diagonal element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights <- lapply(wm_qs, function(x) 0*x + 1)\nb_weights[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 1 1 1 1 1\n```\n\n\n:::\n:::\n\n\nAgain, we use *nb2listw()* and *glist()* to explicitly assign weight values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb_weights2 <- nb2listw(wm_qs, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 536 1072 14160\n```\n\n\n:::\n:::\n\n\nWith our new weight structure, we can compute the lag variable with *lag.listw()*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nw_sum_gdppc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 147903 134605 131165 135423 134635 133381 238106 297281 344573 268982\n[11] 106510 136141 126832 103303 151645 196097 207589 143926 178242 175235\n[21] 138765 155699 160150 117145 113730  89002  63532 112988  59330  35930\n[31] 154439 145795 112587 107515 162322 145517  61826  79925  82589  83352\n[41] 119897 116749  81510  63530 151986 174193 210294  97361  96472 108936\n[51]  79819 108871  48531 128935  84305 188958 171869 148402  83813 104663\n[61] 155742  73336 112705  78084  58257 279414 237883 219273  83354  90124\n[71] 168462 165714 165668 311663 126892 229971 165876 271045 117731 256646\n[81] 126603 127467 295688 336838 267729 431516  85667  51028\n```\n\n\n:::\n:::\n\n\nNext, we will convert the lag variable listw object into a data.frame by using *as.data.frame()*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc.res <- as.data.frame(w_sum_gdppc)\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\n```\n:::\n\n\nThe second command line on the code chunk above renames the field names of *w_sum_gdppc.res* object into *NAME_3* and *w_sum GDPPC* respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, w_sum_gdppc.res)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(NAME_3)`\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan %>%\n  select(\"County\", \"lag_sum GDPPC\", \"w_sum GDPPC\") %>%\n  kable()\n```\n\n::: {.cell-output-display}\n\n\n|County        | lag_sum GDPPC| w_sum GDPPC|geometry                       |\n|:-------------|-------------:|-----------:|:------------------------------|\n|Anxiang       |        124236|      147903|POLYGON ((112.0625 29.75523... |\n|Hanshou       |        113624|      134605|POLYGON ((112.2288 29.11684... |\n|Jinshi        |         96573|      131165|POLYGON ((111.8927 29.6013,... |\n|Li            |        110950|      135423|POLYGON ((111.3731 29.94649... |\n|Linli         |        109081|      134635|POLYGON ((111.6324 29.76288... |\n|Shimen        |        106244|      133381|POLYGON ((110.8825 30.11675... |\n|Liuyang       |        174988|      238106|POLYGON ((113.9905 28.5682,... |\n|Ningxiang     |        235079|      297281|POLYGON ((112.7181 28.38299... |\n|Wangcheng     |        273907|      344573|POLYGON ((112.7914 28.52688... |\n|Anren         |        256221|      268982|POLYGON ((113.1757 26.82734... |\n|Guidong       |         98013|      106510|POLYGON ((114.1799 26.20117... |\n|Jiahe         |        104050|      136141|POLYGON ((112.4425 25.74358... |\n|Linwu         |        102846|      126832|POLYGON ((112.5914 25.55143... |\n|Rucheng       |         92017|      103303|POLYGON ((113.6759 25.87578... |\n|Yizhang       |        133831|      151645|POLYGON ((113.2621 25.68394... |\n|Yongxing      |        158446|      196097|POLYGON ((113.3169 26.41843... |\n|Zixing        |        141883|      207589|POLYGON ((113.7311 26.16259... |\n|Changning     |        119508|      143926|POLYGON ((112.6144 26.60198... |\n|Hengdong      |        150757|      178242|POLYGON ((113.1056 27.21007... |\n|Hengnan       |        153324|      175235|POLYGON ((112.7599 26.98149... |\n|Hengshan      |        113593|      138765|POLYGON ((112.607 27.4689, ... |\n|Leiyang       |        129594|      155699|POLYGON ((112.9996 26.69276... |\n|Qidong        |        142149|      160150|POLYGON ((111.7818 27.0383,... |\n|Chenxi        |        100119|      117145|POLYGON ((110.2624 28.21778... |\n|Zhongfang     |         82884|      113730|POLYGON ((109.9431 27.72858... |\n|Huitong       |         74668|       89002|POLYGON ((109.9419 27.10512... |\n|Jingzhou      |         43184|       63532|POLYGON ((109.8186 26.75842... |\n|Mayang        |         99244|      112988|POLYGON ((109.795 27.98008,... |\n|Tongdao       |         46549|       59330|POLYGON ((109.9294 26.46561... |\n|Xinhuang      |         20518|       35930|POLYGON ((109.227 27.43733,... |\n|Xupu          |        140576|      154439|POLYGON ((110.7189 28.30485... |\n|Yuanling      |        121601|      145795|POLYGON ((110.9652 28.99895... |\n|Zhijiang      |         92069|      112587|POLYGON ((109.8818 27.60661... |\n|Lengshuijiang |         43258|      107515|POLYGON ((111.5307 27.81472... |\n|Shuangfeng    |        144567|      162322|POLYGON ((112.263 27.70421,... |\n|Xinhua        |        132119|      145517|POLYGON ((111.3345 28.19642... |\n|Chengbu       |         51694|       61826|POLYGON ((110.4455 26.69317... |\n|Dongan        |         59024|       79925|POLYGON ((111.4531 26.86812... |\n|Dongkou       |         69349|       82589|POLYGON ((110.6622 27.37305... |\n|Longhui       |         73780|       83352|POLYGON ((110.985 27.65983,... |\n|Shaodong      |         94651|      119897|POLYGON ((111.9054 27.40254... |\n|Suining       |        100680|      116749|POLYGON ((110.389 27.10006,... |\n|Wugang        |         69398|       81510|POLYGON ((110.9878 27.03345... |\n|Xinning       |         52798|       63530|POLYGON ((111.0736 26.84627... |\n|Xinshao       |        140472|      151986|POLYGON ((111.6013 27.58275... |\n|Shaoshan      |        118623|      174193|POLYGON ((112.5391 27.97742... |\n|Xiangxiang    |        180933|      210294|POLYGON ((112.4549 28.05783... |\n|Baojing       |         82798|       97361|POLYGON ((109.7015 28.82844... |\n|Fenghuang     |         83090|       96472|POLYGON ((109.5239 28.19206... |\n|Guzhang       |         97356|      108936|POLYGON ((109.8968 28.74034... |\n|Huayuan       |         59482|       79819|POLYGON ((109.5647 28.61712... |\n|Jishou        |         77334|      108871|POLYGON ((109.8375 28.4696,... |\n|Longshan      |         38777|       48531|POLYGON ((109.6337 29.62521... |\n|Luxi          |        111463|      128935|POLYGON ((110.1067 28.41835... |\n|Yongshun      |         74715|       84305|POLYGON ((110.0003 29.29499... |\n|Anhua         |        174391|      188958|POLYGON ((111.6034 28.63716... |\n|Nan           |        150558|      171869|POLYGON ((112.3232 29.46074... |\n|Yuanjiang     |        122144|      148402|POLYGON ((112.4391 29.1791,... |\n|Jianghua      |         68012|       83813|POLYGON ((111.6461 25.29661... |\n|Lanshan       |         84575|      104663|POLYGON ((112.2286 25.61123... |\n|Ningyuan      |        143045|      155742|POLYGON ((112.0715 26.09892... |\n|Shuangpai     |         51394|       73336|POLYGON ((111.8864 26.11957... |\n|Xintian       |         98279|      112705|POLYGON ((112.2578 26.0796,... |\n|Huarong       |         47671|       78084|POLYGON ((112.9242 29.69134... |\n|Linxiang      |         26360|       58257|POLYGON ((113.5502 29.67418... |\n|Miluo         |        236917|      279414|POLYGON ((112.9902 29.02139... |\n|Pingjiang     |        220631|      237883|POLYGON ((113.8436 29.06152... |\n|Xiangyin      |        185290|      219273|POLYGON ((112.9173 28.98264... |\n|Cili          |         64640|       83354|POLYGON ((110.8822 29.69017... |\n|Chaling       |         70046|       90124|POLYGON ((113.7666 27.10573... |\n|Liling        |        126971|      168462|POLYGON ((113.5673 27.94346... |\n|Yanling       |        144693|      165714|POLYGON ((113.9292 26.6154,... |\n|You           |        129404|      165668|POLYGON ((113.5879 27.41324... |\n|Zhuzhou       |        284074|      311663|POLYGON ((113.2493 28.02411... |\n|Sangzhi       |        112268|      126892|POLYGON ((110.556 29.40543,... |\n|Yueyang       |        203611|      229971|POLYGON ((113.343 29.61064,... |\n|Qiyang        |        145238|      165876|POLYGON ((111.5563 26.81318... |\n|Taojiang      |        251536|      271045|POLYGON ((112.0508 28.67265... |\n|Shaoyang      |        108078|      117731|POLYGON ((111.5013 27.30207... |\n|Lianyuan      |        238300|      256646|POLYGON ((111.6789 28.02946... |\n|Hongjiang     |        108870|      126603|POLYGON ((110.1441 27.47513... |\n|Hengyang      |        108085|      127467|POLYGON ((112.7144 26.98613... |\n|Guiyang       |        262835|      295688|POLYGON ((113.0811 26.04963... |\n|Changsha      |        248182|      336838|POLYGON ((112.9421 28.03722... |\n|Taoyuan       |        244850|      267729|POLYGON ((112.0612 29.32855... |\n|Xiangtan      |        404456|      431516|POLYGON ((113.0426 27.8942,... |\n|Dao           |         67608|       85667|POLYGON ((111.498 25.81679,... |\n|Jiangyong     |         33860|       51028|POLYGON ((111.3659 25.39472... |\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nw_sum_gdppc <- qtm(hunan, \"w_sum GDPPC\")\ntmap_arrange(lag_sum_gdppc, w_sum_gdppc, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n:::\n\n\n### Which method to use?\n\n-   Spatial Lag with Row-Standardized Weights\n\n    -   Use this method when you want each point to have an equal influence across all of its neighbors, regardless of the number of neighbors it has.\n\n    -   It is most appropriate when you expect the spatial relationships to be similar across your dataset (i.e., you don't want points with many neighbors to overwhelm points with fewer neighbors).\n\n    -   Commonly used in **spatial autoregressive models** (SAR) like the **spatial lag model** (SLM).\n\n    -   Typically used in **spatial econometrics** when you’re interested in modeling the spillover effects or dependence of a variable across space.\n\n    -   **Example**: In a housing price study, you might use this if you want to see how the prices of neighboring houses (standardized by distance) affect the price of a given house.\n\n-   Spatial Lag as a Sum of Neighboring Values\n\n    -   Use this method when you want to model the **total influence** of the neighbors without diluting the effect based on the number of neighbors.\n\n    -   It is useful when the **total volume or intensity** of the neighboring values matters, rather than their average or relative influence.\n\n    -   Best for situations where **cumulative effects** are important, like when you're interested in understanding the total influence of surrounding areas (e.g., total population or pollution).\n\n    -   This method might be relevant in studies where **absolute values** are important, such as environmental studies focusing on **total pollution** from neighboring regions.\n\n    -   **Example**: In studying air pollution, you might want the **sum of pollution** from all neighboring areas rather than an average influence, since the total pollution matters.\n\n-   Spatial Window Average\n\n    -   Use this method when you want to calculate a **local average** around each point within a specific window size (e.g., all points within a 10 km radius).\n\n    -   It is useful when you want to smooth the data or when you're focusing on **local averages** rather than global or cumulative effects.\n\n    -   This is often used in **spatial smoothing** or when looking for local trends in spatial data.\n\n    -   In epidemiology, if you’re studying the **average infection rate** within a region (based on nearby regions), you might use a spatial window average to model localized clusters of infection.\n\n-   Spatial Window Sum\n\n    -   Use this method when the **total quantity** or accumulation of a variable in a region is important, and you want to sum the values within a certain distance from each point.\n\n    -   It’s useful for applications where the **cumulative total** of a variable within a region matters more than its average.\n\n    -   This method is often used in environmental studies, resource management, or studies where **total values** in a region (like total population or total resource availability) are critical.\n\n    -   **Example**: In disaster management, if you’re estimating the **total population** within a flood-prone zone, you’d use a spatial window sum to calculate how many people live within the danger area.\n\nUse each method depending on whether you care about relative influence, total influence, local average, or total value.\n",
    "supporting": [
      "Hands-on_Ex05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}