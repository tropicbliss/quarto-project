{
  "hash": "035188c3454a575e08bcf4a41b94fcfe",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class Exercise 5\"\nauthor: \"Eugene Toh\"\nexecute:\n  freeze: true\n---\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(GWmodel, sf, spdep, tmap, tidyverse, knitr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", layer = \"Hunan\")\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\nhunan <- left_join(hunan, hunan2012) %>% select(1:3, 7, 15, 16, 31, 32)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(hunan, \"rds/hunan.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nUse `echo: false` to hide the import.\n\nGWModel is too old to work with sf, so we have to use sp.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sp <- hunan %>% as_Spatial()\n```\n:::\n\n\nThe cool thing about GWModel is that it has features to help us determine the bandwidth. It has two method types, cross validation (`\"CV\"`) and AIC.\n\nTo use fixed distance, just change `adaptive` to `FALSE`. Note that the output is kilometres instead of metres.\n\nNote that if using fixed distance, changing types can yield a large difference. Just experiment with the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_AIC <- bw.gwr(GDPPC ~ 1, data = hunan_sp, approach = \"AIC\", adaptive = TRUE, kernel = \"bisquare\", longlat = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAdaptive bandwidth (number of nearest neighbours): 62 AICc value: 1923.156 \nAdaptive bandwidth (number of nearest neighbours): 46 AICc value: 1920.469 \nAdaptive bandwidth (number of nearest neighbours): 36 AICc value: 1917.324 \nAdaptive bandwidth (number of nearest neighbours): 29 AICc value: 1916.661 \nAdaptive bandwidth (number of nearest neighbours): 26 AICc value: 1914.897 \nAdaptive bandwidth (number of nearest neighbours): 22 AICc value: 1914.045 \nAdaptive bandwidth (number of nearest neighbours): 22 AICc value: 1914.045 \n```\n\n\n:::\n\n```{.r .cell-code}\nbw_AIC\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngwstat <- gwss(data = hunan_sp, vars = \"GDPPC\", bw = bw_AIC, kernel = \"bisquare\", adaptive = TRUE, longlat = T)\n```\n:::\n\n\nNote that the parameters for this and bandwidth calculation must be the same. The bandwidth of 22 neighbours gets interpreted as 22 kilometres if you specify it incorrectly.\n\nThis includes self.\n\nIf you go look at `gwstat[[\"SDF\"]]@data`, it does not have a column that you can easily join with. So first we convert that into a data-frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwstat_df <- as.data.frame(gwstat$SDF)\nhunan_gstat <- cbind(hunan, gwstat_df)\n```\n:::\n\n\n`cbind` simply uses the row number to join. This means that the sequence must not change and hence you cannot sort your data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(hunan_gstat) +\n  tm_fill(\"GDPPC_LM\", n = 5, style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Distribution of geographically weighted mean\", main.title.position = \"center\", main.title.size = 2.0, legend.text.size = 1.2, legend.height = 1.5, legend.width = 1.5, frame = TRUE)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "In-class_Ex05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}