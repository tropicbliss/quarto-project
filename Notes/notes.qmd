---
title: "Notes"
execute:
  freeze: true
---

-   GIS is a software tool to analyse and visualise geographical information, it's not a discipline.

-   Geospatial analysis turns data into information that we can make decisions on.

-   Geospatial data is data stored in a special database that can be thought of as a simplified model of the real world.

-   **What is a dataframe?**

-   Types of geospatial data

    -   Vector

        -   Stores data that are discrete in nature (you can count the total number of data that is representable)

        -   The SVG of geospatial data

        -   Data primitives (simple features)

            -   Points

                -   Coordinate

                -   Examples

                    -   Landmarks

            -   Polyline (line + polygon)

                -   Series of coordinates known as vertices (though like other data types they might also contain additional metadata such as road names)

                -   Examples

                    -   Roads

            -   Polygon

                -   Consists of three or more line segments, and the starting and end coordinates must be the same, but how they are stored is almost the same as how vertices are stored in a polyline.

                -   Buildings

    -   Raster (simple features)

        -   Stores data that are continuous in nature (data that does not have a clear cut off point)

        -   The JPEG of geospatial data

        -   Elevation

        -   The area of interest is divided into cells (which are essentially pixels on the screen). A grid typically only stores a single attribute of the area of interest, and each grid is responsible for a certain real world area size (such as 10x10 metres). The data stored in each grid is fixed. For instance, a grid can store a single 32 bit floating point value.

-   Coordinate system

    -   Coordinates stored in different coordinate systems will have wildly different values relative to each other.

    -   Types

        -   Geographical coordinate systems

            -   Uses a three dimensional system to encode data

                -   Latitude

                    -   Vertical line

                    -   0 degrees at the equator, +90 degrees in the north pole and -90 degrees in the south pole

                -   Longitude

                    -   Horizontal line

                        -   0 degrees at Greenwich

                            -   0 to +180 degrees (east)

                            -   0 to -180 degrees (west)

                -   Datum

                    -   Defines the shape and the size of the earth as the equator or Greenwich while being used as a reference for the coordinate system does not define how much it varies as you stray further away from it.

                    -   Examples

                        -   WGS84

                            -   Defines the earth as an ellipsoid

            -   Not suitable for distance measurement as it takes the curvature of the earth into account which makes it more challenging to calculate. A single degree of difference can lead to different distances depending on the coordinates of the start and end points.

        -   Projected coordinate system

            -   Examples

                -   SVY21 (Singapore)

            -   Provides consistent area measurements.

            -   Important to convert from GCS to PCS before conducting analysis.

            -   Large countries might use multiple PCS.

            -   Each country or state might have their own PCS to minimise distortions from projecting a spherical surface into a plane, to create an accurate representation of an area.

-   Simple features

    -   There are about 17 of them, 3 of them having been mentioned above.

    -   Most software typically only use a subset of them.

    -   Types

        -   Point

            -   `Point(30, 10)`

        -   Multi point

            -   `MultiPoint([Point(10, 40), Point(40, 30), Point(20, 20), Point(30, 10)])`

        -   Line string

            -   `LineString([Point(30, 10), Point(10, 30), Point(40, 40)])`

        -   Polygon

            -   `Polygon([Point(30, 10), Point(40, 40), Point(20, 40), Point(10, 20), Point(30, 10)])`

            -   `Polygon([[Point(35, 10), Point(45, 45), Point(15, 40), Point(10, 20), Point(35, 10)], [Point(20, 30), Point(35, 35), Point(30, 20), Point(20, 30)]])`

        -   MultiX

            -   "Multi" versions of the above primitives but have them be elements of an array.

    -   To work with simple features, you can use the `sf` package from R which is part of the `tidyverse` collection.

    -   Simple features are represented via "simple features geometry (SFG)", and they and geospatial data can be represented with "simple features objects (SFO)" which represent a collection of SFG as a data-frame object. The non-spatial data (metadata) are stored in a separate column separate from the SFG column. The data type of that SFG column is known as "simple features collection (SFC)".

-   `sf` functions

    -   `sf` also provides functions that help you in doing data manipulation and analysis of spatial data.

    -   `st_read`: import a file or database into a SFO (more flexible but slower)

        -   `read_sf`: import a file or database into a SFO (less flexible but more optimised)

        -   Supported file formats

            -   Shapefile

                -   A misnomer as it is basically a collection of files (hence a single `shp` file is not enough). File extensions include: `dbf`, `prj`, `shp`, `xml`, and `shx`.

                    ```         
                    sf_mpsz = st_read(dsn = "data/geospatial", layer = "MP14_SUBZONE")
                    st_write(st_poly, "data/my_poly.shp")
                    ```

            -   MapInfo TAB

            -   KML (Google)

                ```         
                sf_preschool = st_read("data/geospatial/pre-schools-location-kml.kml")
                ```

                You need to provide the file extension if it is not a Shapefile.

            -   GML

            -   GeoJSON (popular in web)

            -   TopoJSON (popular in web)

    -   `st_write`: export a file from a SFO to a file or database

        -   `write_sf`: export a file from a SFO to a file or database (less flexible but more optimised)

    -   `st_as_sf`: convert existing data structures into a SFO

    -   `st_as_text`: convert a SFO into "well-known text" (WKT) (it is the `to_string()` of SFO and represents the SFO data structure in a textual format)

    -   `st_as_binary`: converts a SFO into a binary format

    -   `st_transform`: Convert a SFO into another SFO with a different coordinate reference system via an EPSG code. For example, it can convert GCS data to PCS.

        -   A coordinate reference system is a system that specifies the datum (among other attributes) of the coordinate system. It can be represented as a numerical code known as the EPSG code.

    -   `st_intersects`: whether two geometries touch or overlap each other

        -   Note that many `sf` functions may sound similar to each other but perform totally different tasks. For instance, `st_intersects` merely tells you which geometry intersects with each other while `st_intersection` will create new geometry that shows the areas of intersection.

        -   In short, `st_intersects` checks whether each geometry in each SFO intersects with each other. Many other functions in this category work the same way. Like many other functions in this category, it returns a sparse list.

        -   Sparse lists

            -   A sparse list is a way of efficiently representing the relationship of a geometry in one set with respect to another geometry in another set without using a full matrix.

            -   Using `st_intersects`:

                ```         
                # Example sparse list
                result <- list(
                  c(2, 3),
                  integer(0),
                  c(1, 4)
                )
                ```

                -   `result[[1]]` (First Geometry in `A`):

                    -   The first element `c(2, 3)` means that the first geometry in `A` intersects with the 2nd and 3rd geometries in `B`.

                -   `result[[2]]` (Second Geometry in `A`):

                    -   The second element `integer(0)` (an empty integer vector) means that the second geometry in `A` does not intersect with any geometry in `B`.

                -   `result[[3]]` (Third Geometry in `A`):

                    -   The third element `c(1, 4)` means that the third geometry in `A` intersects with the 1st and 4th geometries in `B`.

                -   Note that sparse lists do not include symmetric pairs, e.g., `(2, 4` and `(4, 2)` are repeated.

    -   Functions that return a logical matrix indicating whether each geometry pair meets the logical operation

        -   `st_disjoint`: equivalent to performing a NOT boolean operation on the result of `st_intersects`

        -   `st_touches`: touch

        -   `st_crosses`: cross

        -   `st_within`: within

        -   `st_contains`: overlap

        -   `st_overlaps`: overlaps

        -   `st_covers`: cover

        -   `st_covered_by`: covered by

        -   `st_equals`: equals

        -   `st_equals_exact`: equals, with some fuzz

            -   Returns a sparse (default) or dense logical matrix.

    -   Geometry generating logical operators:

        -   `st_union`: union of several geometries

        -   `st_intersection`: intersection of pairs of geometries

        -   `st_difference`: difference between pairs of geometries

            -   If `st_difference(A, B)`, take `A` and subtract any areas of overlap by `B`.

        -   `st_sym_difference`: symmetric difference (XOR)

            -   Equivalent to `st_union(st_difference(A, B), st_difference(B, A))`.

    -   Higher level operations

        -   `aggregate`

        -   `summarise`

        -   `st_interpolate_aw`: area-weighted interpolation of attributes from one set of geometries to another

            -   Area-weighted interpolation is a spatial analysis technique used to estimate or transfer values from one set of spatial units (e.g., polygons) to another set of spatial units that may overlap or have different boundaries. For instance, you might have census tracts for population and want to map out the population of each district. The census tract does not match the district. Hence, you will want to use this function to transfer population data over.

            -   You need to specify the source and target geometries, each of which are SFOs, but the target geometry does not need to have any attributes. You also need to specify whether the interpolation is done extensively or intensively.

            -   In extensive interpolation, you need to sum the contributions from each source polygon based on the proportion of its area that overlaps with the target polygon. For example, if you have a source polygon with a population of 1000 people and it overlaps by 50% with a target polygon, the area-weighted interpolation would allocate 500 people to the target polygon.

            -   Intensive attributes are those that are independent of the size or extent of the spatial unit they are associated with. These attributes describe a characteristic that does not change when you change the size of the area. An example of an intensive attribute is population density. For example, if one source polygon has a population density of 200 people per square kilometer and overlaps by 50% with a target polygon, and another source polygon has a density of 100 people per square kilometer and overlaps by 50%, the resulting population density in the target polygon would be the weighted average of these densities.

        -   `st_join`: performs spatial joins between two SFOs

            -   A spatial join merges attributes from one SFO to another.

            -   The output SFO will retain the geometries of the first input SFO.

            -   Think of the second input SFO as an overlay for the first SFO.

                [![Illustration of st_join](https://r-spatial.github.io/sf/reference/st_join-1.png)](https://r-spatial.github.io/sf/reference/st_join.html)

                Observe that `st_join` does not do any interpolation or any mathematical operations. It also does not include any points in `b`. Any repeating data from the merge is included in the final output as an additional row.

                ```{r}
                pacman::p_load(sf)
                a = st_sf(a = 1:3,
                 geom = st_sfc(st_point(c(1,1)), st_point(c(2,2)), st_point(c(3,3))))
                b = st_sf(a = 11:15,
                 geom = st_sfc(st_point(c(10,10)), st_point(c(2,2)), st_point(c(2,2)), st_point(c(3,3)), st_point(c(12,12))))
                st_join(a, b)
                ```

    -   Manipulating geometries (spatial data wrangling) (generates new data out of existing data) (the output SFC does not contain any input data)

        -   `st_line_merge`: merges lines

        -   `st_segmentize`: adds points to straight lines

        -   `st_voronoi`: creates voronoi tesselation

        -   `st_centroid`: gives centroid of geometry

            -   Outputs a SFC containing points corresponding to the centre of each geometry.

        -   `st_convex_hull`: creates convex hull of set of points

        -   `st_triangulate`: triangulates sets of points (not constrained)

        -   `st_polygonize`: creates polygon from lines that form a closed ring

        -   `st_simplify`: simplifies lines by removing vertices

        -   `st_split`: split a polygon given line boundary

        -   `st_buffer`: compute a buffer around this geometry/each geometry

            -   Creates a region that expands outwards from each geometry by a given distance, creating a buffer zone.

            -   For points, it creates a circular buffer. For lines, it creates a buffer along the entire length of the line, creating a polygon that surrounds the line. For polygons, it expands the polygon by a given distance, keeping it's shape, resulting in a scaled up version of the original polygon.

            -   Returns a SFC containing only the buffer.

            -   Uses the unit of measurement specified by the PCS, e.g., SVY21 (Singapore) uses metres as the unit of measurement.

        -   `st_make_valid`: tries to make an invalid geometry valid (requires `lwgeom`)

        -   `st_boundary`: returns the boundary of a geometry

    -   Convenience functions

        -   `st_zm`: sets or removes z and/or m geometry

        -   `st_coordinates`: retrieves coordinates in a matrix or data frame

        -   `st_geometry`: sets, or retrieves SFC from an SFO

            -   Returns the SFC.

        -   `st_is`: checks whether a geometry is of a particular type
